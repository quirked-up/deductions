<!DOCTYPE HTML>
<html lang=en>
	<head>
		<meta charset=utf-8>
		<title>Semantic Tableux</title>
		<style>
/*			* {outline: dotted 1px red}*/
			td:first-child {
				padding-right: 1em;
			}
			td {
				padding: 0.2em 0.5em;
				text-align: center;
				vertical-align: top;
			}
			td:last-child {
				text-align: left;
				padding-left: 5em;
			}
			.split, .splitL, .splitR {
				background: url(./split.svg);
				padding: 0.5em;
			}
			.splitL {
				background: url(./splitR.svg);
				padding-right: 0;
			}
			.splitR {
				background: url(./splitL.svg);
				padding-left: 0;
			}
			.straight {
				background: url(./line.svg);
				padding: 0;
			}

			.splitL, .splitR, .straight, .split {
				background-size: 100% 100%;
			}
			table { border-spacing: 0 }

			table button {
				flex-grow: 1;
			}

		</style>
	</head>

	<body>

		<table id=tree>
			<tr><td>1.<td contenteditable><td contenteditable>
			<tr><td><td><button title="add node to branch">+</button> <button title="split branch">/\</button> <button title="close branch">X</button><td>
		</table>

		<script>
			tree.addEventListener('input', fix_lines)
			tree.addEventListener('click', ({target})=>{
				if (target.tagName != 'BUTTON') return

				const td = target.parentElement,
				tr = td.parentElement
				const table = tr.parentElement.parentElement

				var col = 0
				for (let i=0; i<td.cellIndex; i++)
					col += tr.cells[i].colSpan + +(tr.cells[i].dataset.psuedo_colspan || 0)
				var total_cols = col
				for (let i=td.cellIndex; i<tr.cells.length; i++)
					total_cols += tr.cells[i].colSpan + +(tr.cells[i].dataset.psuedo_colspan || 0)

				switch (target.title) {
					case "add node to branch":
						var [i, row] = next_empty_row(table, total_cols, tr.rowIndex)

						make_editable(cell_in_col(row, col))

						if (tr.rowIndex < i) {
							td.replaceWith(document.createElement('td'))
							for (let j=tr.rowIndex; j<i; j++) {
								let td = cell_in_col(table.rows[j], col)
								td.classList.add('straight')
							}
						}

						cell_in_col(get_or_make_row(table, i+1, total_cols), col).replaceWith(td)
						break

					case "split branch":
						for (let i=0; i<tr.rowIndex; i++)
							widen_cell_in_col(table.rows[i], col)


						var [i, row] = next_empty_row(table, total_cols, tr.rowIndex+1)

						const right = document.createElement('td')
						right.className = "splitR"
						const left = document.createElement('td')
						left.className = "splitL"
						left.rowSpan = right.rowSpan = i - tr.rowIndex
						td.replaceWith(right)
						right.before(left)

						for (let j=tr.rowIndex+1; j<i; j++) {
							let td = cell_in_col(table.rows[j], col+1)
							td.dataset.psuedo_colspan = 2
							td.previousElementSibling.remove()
						}

						for (let j=i; j<table.rows.length; j++) {
							cell_in_col(table.rows[j], col).before(document.createElement('td'))
						}
						total_cols++

						let slot = make_editable(cell_in_col(table.rows[i], col))
						make_editable(slot.nextElementSibling) 

						cell_in_col(get_or_make_row(table, i+1, total_cols), col).replaceWith(td)
						td.nextElementSibling.replaceWith(td.cloneNode(true))
						break

					case "close branch":
						let new_td = document.createElement('td')
						new_td.contentEditable = true
						new_td.innerText = 'ðŸ—¸'
						td.replaceWith(new_td)
						break

				}
				fix_lines()
			})
			function next_empty_row(table, total_cols, after_row_indx=0) {
				var i
				for (i=after_row_indx; i<table.rows.length; i++)
					if (table.rows[i].classList.contains('empty'))
						break
				return [i, get_or_make_row(table, i, total_cols)]
			}
			// psuedo_colspan is colSpan of all immediately previous cells from above rows (ie with rowSpan > 1) 
			function cell_in_col(row, target_col) {
				var cols = 0
				for (let i=0; i<row.cells.length; i++) {
					cols += row.cells[i].colSpan + +(row.cells[i].dataset.psuedo_colspan || 0)
					if (cols > target_col)
						return row.cells[i]
				}
				throw `${row} has no column ${target_col}`
			}
			function widen_cell_in_col(row, target_col) {
				var cols = 0
				for (let i=0; i<row.cells.length; i++) {
					cols += row.cells[i].colSpan
					if (cols > target_col)
						return row.cells[i].colSpan++
					cols += +(row.cells[i].dataset.psuedo_colspan || 0)
					if (cols > target_col)
						return row.cells[i].dataset.psuedo_colspan++
				}
				throw `${row} has no column ${target_col}`
			}

			function make_editable(cell) {
				const row = cell.parentElement
				row.firstElementChild.innerText = row.rowIndex + '.'
				row.lastElementChild.contentEditable = true
				row.classList.remove('empty')

				const td = document.createElement('td')
				td.contentEditable = true
				cell.replaceWith(td)

				return td
			}

			function get_or_make_row(table, i, total_cols) {
				while (i >= table.rows.length) {
					let row = table.insertRow()
					for (let j=0; j<total_cols; j++)
						row.insertCell()
					row.classList.add('empty')
				}
				return table.rows[i]
			}



			var max_ratio = 99
			var min_length = 0
			function fix_lines () {
				[...document.querySelectorAll('.splitL')].reverse().forEach(left=> {
					const right = left.nextElementSibling

					left.width = right.width = ''


					var l = left.offsetWidth, r = right.offsetWidth
					var midpoint = (l+r)/2
					if (l/2 < min_length) {
						left.width = min_length * 2
						l = left.offsetWidth
						midpoint = (l+r)/2
					}
					if (r/2 < min_length) {
						right.width = min_length * 2
						r = right.offsetWidth
						midpoint = (l+r)/2
					}

					if (l*max_ratio < r) {
						left.width = r/max_ratio
					} else if (r*max_ratio < l) {
						right.width = l/max_ratio
					}
					l = left.offsetWidth, r = right.offsetWidth
					midpoint = (l+r)/2




					left.style.transform = `translateX(${midpoint}px)`
					right.style.transform = `translateX(${-midpoint}px)`
				})
			}
		</script>
	</body>
</html>